<!DOCTYPE html>
<html dir="ltr" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />

    <title>2022 DC ANC Elections | GGWash</title>

    <script type="module" src="./../build/dc-election.esm.js"></script>
    <script nomodule src="./../build/dc-election.js"></script>

<!-- <script src="https://js.arcgis.com/4.24/" data-esri-loader="loaded"></script>
  <link rel="stylesheet" href="https://js.arcgis.com/4.21/esri/themes/light/main.css"> -->
<link rel='stylesheet' type='text/css' href='https://unpkg.com/@esri/calcite-components@1.0.0-next.292/dist/calcite/calcite.css' />
<script type='module' src='https://unpkg.com/@esri/hub-components@4.0.0-beta.341/dist/hub-components/hub-components.esm.js'></script>
  </head>
  <body>
  
  <div class="navbar">
  </div>  
  <div class="main">
    <dc-election-survey 
        id="anc" 
        filename="./../assets/2022_anc.csv" 
        format="surveymonkey"
        show-filter=true
        filter=""
      >
      <h2 slot="title">DC ANC</h2>
      <div slot="filter">
        <arcgis-hub-map
            style='height: 400px;'
            zoom="10"
            center="-77.05,38.9"
            basemap="gray-vector"
        ></arcgis-hub-map>
      </div>
    </dc-election-survey>
  </div>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }

    .navbar, .main {
      padding: 0 8px;
    }
    /* The navigation bar */
    .navbar {
      overflow: hidden;
      background-color: white;
      position: fixed; /* Set the navbar to fixed position */
      top: 0; /* Position the navbar at the top of the page */
      width: 100%; /* Full width */
      box-shadow: 0 3px 5px rgba(57, 63, 72, 0.3);      
    }

    .navbar h1 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }
    /* Links inside the navbar */
    .navbar a {
      float: left;
      display: block;
      text-align: center;
      padding: 14px 16px;
      text-decoration: none;
    }

    /* Change background on mouse-over */
    .navbar a:hover {
      background: #ddd;
      color: black;
    }

    /* show horizontal scope */
    #parking {
      min-width: 1300px;
      overflow: scroll;
    }

    /* Main content */
    .main {
      margin-top: 0; /* Add a top margin to avoid content overlay */
    }
    dc-election-survey {
      scroll-margin-top: 60px;
    }    

  </style>

  <script>
    
    const $surveyEl = document.querySelector('dc-election-survey');
    $surveyEl.addEventListener('filterChanged', (event => {
      console.log("HTML filter changed", event)
      let filter = event.detail.value;
      filter = filter.slice(0,2);
      setFilter(filter);
    }))

    function setFilter( filter ) {
      console.log("setFilter", {filter})
      $surveyEl.filter = filter;
      selectFeature({ attributes: { NAME: filter } })
    }
    
    let m_view, m_layerView, ancLayer, smdLayer;
    let highlight, currentFilter;
    
    const $mapEl = document.querySelector('arcgis-hub-map');
    $mapEl.addEventListener('arcgisHubMapViewReady', function (event) {
        const { detail: { view, loadModules } } = event;
        m_view = view;

        loadModules([
            'esri/geometry/Extent',
            'esri/layers/FeatureLayer',
            'esri/widgets/Home',
            "esri/layers/support/LabelClass",
            'esri/widgets/Search'
        ])
        .then( ([Extent, FeatureLayer, Home, LabelClass, Search]) => {
            // Add ANC Boundaries
            const ancStyle = {
              type: "simple",
              symbol: { type: "simple-fill",
              opacity: 0,
                outline: {  // autocasts as new SimpleLineSymbol()
                  width: 1,
                  color: [30,30,30,0.5]
                } 
              }
            }
            const ancLabels = new LabelClass({
              labelExpressionInfo: { expression: "$feature.NAME" },
              symbol: {
                type: "text",  // autocasts as new TextSymbol()
                color: "white",
                haloSize: 0.5,
                haloColor: "black",
                font: {
                  size: 12,
                  weight: "bold"
                }
              }
            });

            // from https://opendata.dc.gov
            ancLayer = new FeatureLayer({
                url: "https://maps2.dcgis.dc.gov/dcgis/rest/services/DCGIS_DATA/Administrative_Other_Boundaries_WebMercator/MapServer/54",
                renderer: ancStyle,
                labelingInfo: [ ancLabels ]
            });

            const smdStyle = {
              type: "simple",
              symbol: { 
                type: "simple-fill",
                opacity: 0,
                outline: {  // autocasts as new SimpleLineSymbol()
                  width: 0.5,
                  color: "white"
                }
              }
            }
            const smdLabels = new LabelClass({
              labelExpressionInfo: { expression: "$feature.SMD_ID" },
              symbol: {
                type: "text",  // autocasts as new TextSymbol()
                color: "white",
                haloSize: 0.5,
                haloColor: "black",
                font: {
                  size: 8
                },
                maxScale: 0,
                minScale: 1000000,
              }
            });
            // from https://opendata.dc.gov
            smdLayer = new FeatureLayer({
              url: "https://maps2.dcgis.dc.gov/dcgis/rest/services/DCGIS_DATA/Administrative_Other_Boundaries_WebMercator/MapServer/55",
              renderer: smdStyle,
              labelingInfo: [ smdLabels ]
            })

            m_view.map.add(smdLayer);
            m_view.map.add(ancLayer);

            m_view.highlightOptions = {
              color: "#0f9535"
            }

            // Washington, DC
            const theExtent = new Extent({
              xmin:-8584947.85844689,
              ymin:4691862.387048862,
              xmax:-8561472.787091771,
              ymax:4721095.072076196,
              spatialReference: {
                wkid: 3857
              }
            });
            m_view.constraints = {
              geometry: theExtent,
              minScale: 500000, 
              maxScale: 10000, 
              rotationEnabled: false
            };

            // m_view.ui.components = ["zoom"];
            const searchExtent = {
              geometry: theExtent
            };
            const sources = [{
                url: "https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer",
                name: "DC Address Search",
                zoomScale: 50000,
                filter: searchExtent
              },{
                layer: ancLayer,
                placeholder: "Search ANC",
                maxResults: 5,
                searchFields: ["NAME"],
                displayField: "NAME",
                name: "DC ANC"
              }];
            const searchWidget = new Search({
              view: m_view,
              includeDefaultSources: false,
              sources: sources
            });
            // Adds the search widget below other elements in
            // the top left corner of the view
            m_view.ui.add(searchWidget, {
              position: "top-left",
              index: 2
            });
            let homeWidget = new Home({
              view: m_view
            });
            view.ui.add(homeWidget, "top-left");
            view.ui.move("zoom", "top-right");

            searchWidget.on("search-complete", function(event){
              // The results are stored in the event Object[]
              let feature = event.results[0].results[0].feature;
              let query = m_layerView.createQuery();
              query.geometry = feature.geometry;
              console.log("Results of the search: ", {query, feature, event});
              
              ancLayer.queryFeatures(query).then((result) => {
                console.log("query", result);
                let resultFeature = result.features[0];
                setFilter(resultFeature.attributes.NAME);
              });
            });

          m_view
              .when()
              .then(() => {
                return ancLayer.when();
              })
              .then((layer) => {
                return m_view.whenLayerView(layer);
              })
              .then((layerView) => {
                m_layerView = layerView;

                m_view.on("pointer-move",mapMouseHandler);
                m_view.on("pointer-down",mapMouseHandler);
              })
        });
    });  

    function mapMouseHandler(event) {
      const opts = {
        include: ancLayer
      }

      m_view.hitTest(event, opts).then((response) => {
        if (response.results.length) {
          const feature = response.results[0].graphic;
          highlightFeature(feature)
          // currentANCName = response.results[0].graphic.attributes["NAME"];
          if(event.type === "pointer-down") {
            setFilter(currentFilter);  
          }
        }
      });   
      
    }                    

    function selectFeature(feature) {
      const query = m_layerView.createQuery();
      query.where = `NAME = '${feature.attributes.NAME}'`;
      m_layerView.queryFeatures(query).then((result) => {
        if (highlight) {
          highlight.remove();
        }
        let feature = result.features[0];
        highlight = m_layerView.highlight(feature.attributes.OBJECTID);
        m_view.goTo(
          {
            target: feature.geometry
          },
          {
            duration: 2000,
            easing: "in-out-expo"
          }
        )
      });
      // m_layerView.featureEffect = {
      //   filter: {
      //     where: `NAME = '${feature.attributes.NAME}'`
      //   },
      //   includedEffects: [
      //     {
      //       value: "invert(75%)"
      //     },
      //   ],
      //   excludedEffects: [
      //     {
      //       value: "opacity(0%)"
      //     },
      //   ]
      // }
    }
    function highlightFeature(feature) {
      currentFilter = feature.attributes.NAME;

      const query = m_layerView.createQuery();
      query.where = `NAME = '${feature.attributes.NAME}'`;
      ancLayer.featureEffect = {
        filter: {
          where: `NAME = '${feature.attributes.NAME}'`
        },
        excludedLabelsVisible: true,
        includedEffects: "brightness(5) hue-rotate(270deg) contrast(200%)",
        excludedEffects: "invert(30%)"
      }
      // m_layerView.queryFeatures(query).then((ids) => {
      //   if (highlight) {
      //     highlight.remove();
      //   }
      //   // highlight = m_layerView.highlight(ids.features[0].attributes.OBJECTID);
      // }); 
    }
      
  </script>
  </body>
</html>
